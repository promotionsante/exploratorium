---
title: "flat_filter_project_data.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(dplyr)
library(readr)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Load projects data

```{r function-load_projects_data}
#' Load projects data from disk
#' 
#' @param language A characer. Either "fr" or "de"
#' 
#' @return A sf data.frame
#' 
#' @noRd
load_projects_data <- function(language) {
  stopifnot(
    "Unknown language provided" = language %in% c("fr", "de")
  )
  readRDS(
    file = app_sys(
      "data-projects",
      sprintf("projects_%s.rds", language)
    )
  )
}
```

```{r example-load_projects_data}
load_projects_data(
  language = "fr"
)
```

```{r tests-load_projects_data}
test_that("load_projects_data() returns sf objects", {
  projects_de <- load_projects_data(
    language = "de"
  )
  projects_fr <- load_projects_data(
    language = "fr"
  )
  expect_s3_class(projects_de, "sf")
  expect_s3_class(projects_fr, "sf")
})

test_that("load_projects_data() returns an error if unknow language provided", {
  expect_error(
    load_projects_data(
      language = "es"
    ),
    regexp = "Unknown language provided"
  )
})
```

# Filter projects data

```{r function-filter_projects_data}
#' Filter projects data
#' 
#' Main function that powers the filtering of  mod_projects_selection_*()
#' 
#' @param projects_data_sf A sf data.frame. 
#' @param vec_topics A character vector of topics 
#' @param range_budget A numeric vector of size two defining the lower and 
#' upper bound of budget.
#' @param range_self_funded_budget A numeric vector of size two defining the lower and
#'  upper bound of self-funded budget.
#' @param canton_main_resp_orga A character vector containing the names of the 
#' cantons of interest.
#'
#' @importFrom dplyr if_any
#'
#' @return A sf data.frame
#' 
#' @noRd
filter_projects_data <- function(
    projects_data_sf,
    vec_topics = NULL,
    range_budget,
    range_self_funded_budget,
    canton_main_resp_orga
) {
  if ( 
    !missing(vec_topics) 
  ) {
    projects_data_sf <- projects_data_sf |>
      filter(
        if_any(
          contains(vec_topics),
          ~ .x == 1
        )
      )
  }  
  #   filter(
  #     total_budget |> between(
  #       min(range_budget), 
  #       max(range_budget)
  #     ),
  #     budget_orga |> 
  #       between(
  #         min(range_self_funded_budget), 
  #         max(range_self_funded_budget)
  #       )
  #   )
  return(projects_data_sf)
}
```


```{r example-filter_projects_data}
projects_fr <- load_projects_data(
  language = "fr"
)
filter_projects_data(projects_fr)
```


```{r tests-filter_projects_data}
test_that("filter_projects_data() returns sf objects", {
  projects_de <- load_projects_data(
    language = "de"
  )
  projects_fr <- load_projects_data(
    language = "fr"
  )
  expect_s3_class(filter_projects_data(projects_de), "sf")
  expect_s3_class(filter_projects_data(projects_fr), "sf")
})
```



# Get input data to display
    
```{r function-get_input_data_to_display}
#' Base function to get input values to be displayed
#' 
#' @param language A character either "fr" or "de".
#' @param pattern A character. Pattern for column names to be 
#' extracted from variable dic.
#' 
#' @return A named vector
#' 
#' @importFrom readr read_csv2
#' @noRd
get_input_data_to_display <- function(
    language,
    pattern
) {
  
  dic_variables <- suppressMessages(
    read_csv2(
      file = app_sys("data-dic/dic_variables.csv"),
      show_col_types = FALSE
    )
  )
  
  input_dic <- dic_variables[
    grep(pattern, dic_variables$name_variable), 
  ]
  
  inputs_to_diplay <- input_dic$name_variable
  names(inputs_to_diplay) <- input_dic[[language]]

  return(inputs_to_diplay)
}
```
  
```{r example-get_input_data_to_display}
get_input_data_to_display(
  language = "fr",
  pattern = "^topic_"
)
```
  
```{r tests-get_input_data_to_display}
test_that("get_input_data_to_display() works", {
  expect_error(
    get_input_data_to_display(
      language = "fr",
      pattern = "^topic_"
    ),
    NA
  )
})
```


# Get unique topics to display

```{r function-get_topics_to_display}
#' Get unique topics to display 
#'
#' and put "other" topics at the end.
#' 
#' @inheritParams get_input_data_to_display
#' 
#' @return A named character vector ending with "Other" (andere/autre) topics.
#' Names correspond to FR or DE translation displayed to the user.
#' 
#' 
#' @noRd
get_topics_to_display <- function(language) {
  get_input_data_to_display(
    language = language,
    pattern = "^topic_"
  )
}
```

```{r example-get_topics_to_display}
get_topics_to_display(
  language = "fr"
)
```

```{r tests-get_topics_to_display}
test_that("get_topics_to_display() works in FR", {
  
  topics_to_display <- get_topics_to_display(
    language = "fr"
  )
  
  expect_type(
    topics_to_display,
    "character"
  )
  
  # Other topics are featured at the very end of the vector
  id_other_topics <- grep("Andere|Autre", topics_to_display)
  expect_setequal(
    id_other_topics,
    seq(
      from = length(topics_to_display), 
      length.out = length(id_other_topics), 
      by = -1
    )
  )
})

test_that("get_topics_to_display() works in DE", {
  
  topics_to_display <- get_topics_to_display(
    language = "de"
  )
  
  expect_type(
    topics_to_display,
    "character"
  )
  
  # Other topics are featured at the very end of the vector
  id_other_topics <- grep("Andere|Autre", topics_to_display)
  expect_setequal(
    id_other_topics,
    seq(
      from = length(topics_to_display), 
      length.out = length(id_other_topics), 
      by = -1
    )
  )
})

```

# Get unique pi1 todisplay
    
```{r function-get_pi1_to_display}
#' @inheritParams get_input_data_to_display
#' 
#' @noRd
get_pi1_to_display <- function(language){
  pi1_to_display <- get_input_data_to_display(
    language = language,
    pattern = "^pi_1_"
  )
  # Remove PI 1 prefix
  names(pi1_to_display) <- gsub(
    pattern = "PI 1 *: ",
    replacement = "",
     names(pi1_to_display)
  )
  return(pi1_to_display)
}
```
  
```{r example-get_pi1_to_display}
get_pi1_to_display("fr")
```
  
```{r tests-get_pi1_to_display}
test_that("get_pi1_to_display() returns well formed named vector in FR", {
  pi1_to_display <- get_pi1_to_display("fr")
  expect_length(
    pi1_to_display,
    3
  )
  expect_type(
    pi1_to_display,
    "character"
  )
  expect_true(
    !is.null(
      names(pi1_to_display)
    )
  )
  expect_true(
    all(
      !grepl(
        "^P1 : ",
        x = names(pi1_to_display)
      )
    )
  )
})

test_that("get_pi1_to_display() returns well formed named vector in DE", {
  pi1_to_display <- get_pi1_to_display("de")
  expect_length(
    pi1_to_display,
    3
  )
  expect_type(
    pi1_to_display,
    "character"
  )
  expect_true(
    !is.null(
      names(pi1_to_display)
    )
  )
  expect_true(
    all(
      !grepl(
        "^P1 *: ",
        x = names(pi1_to_display)
      )
    )
  )
})

```

# Get unique pi2 todisplay
    
```{r function-get_pi2_to_display}
#' @inheritParams get_input_data_to_display
#' 
#' @noRd
get_pi2_to_display <- function(language){
     pi1_to_display <- get_input_data_to_display(
    language = language,
    pattern = "^pi_2_"
  )
  # Remove PI 1 prefix
  names(pi1_to_display) <- gsub(
    pattern = "PI 2 *: ",
    replacement = "",
     names(pi1_to_display)
  )
  return(pi1_to_display)
}
```
  
```{r example-get_pi2_to_display}
get_pi2_to_display("fr")
```
  
```{r tests-get_pi2_to_display}
test_that("get_pi2_to_display() returns well formed named vector in FR", {
  pi2_to_display <- get_pi2_to_display("fr")
  expect_length(
    pi2_to_display,
    3
  )
  expect_type(
    pi2_to_display,
    "character"
  )
  expect_true(
    !is.null(
      names(pi2_to_display)
    )
  )
  expect_true(
    all(
      !grepl(
        "^P2 : ",
        x = names(pi2_to_display)
      )
    )
  )
})

test_that("get_pi2_to_display() returns well formed named vector in DE", {
  pi2_to_display <- get_pi2_to_display("de")
  expect_length(
    pi2_to_display,
    3
  )
  expect_type(
    pi2_to_display,
    "character"
  )
  expect_true(
    !is.null(
      names(pi2_to_display)
    )
  )
  expect_true(
    all(
      !grepl(
        "^P2 *: ",
        x = names(pi2_to_display)
      )
    )
  )
})

```
  

# Get budget range
    
```{r function-get_budget_range}
#' @noRd
get_budget_range <- function(
    projects_data_sf
){
  range(
    projects_data_sf[["total_budget"]], 
    na.rm = TRUE
  )
}
```

```{r example-get_budget_range}
load_projects_data("de") |> 
  get_budget_range()
```

```{r tests-get_budget_range}
test_that("get_budget_range() yield well formed range in FR", {
  projects_data_sf <- load_projects_data("fr") 
  budget_range <- get_budget_range(projects_data_sf)
  expect_length(
    budget_range,
    2
  )
  expect_type(
    budget_range,
    "double"
  )
})
test_that("get_budget_range() yield well formed range in DE", {
  projects_data_sf <- load_projects_data("de") 
  budget_range <- get_budget_range(projects_data_sf)
  expect_length(
    budget_range,
    2
  )
  expect_type(
    budget_range,
    "double"
  )
})
```

# Get range of self funded budget
    
```{r function-get_prop_self_funded_range}
#' @noRd
get_prop_self_funded_range <- function(
    projects_data_sf  
){
  prop_self_funded_range <- range(
    projects_data_sf[["prop_budget_orga"]],
    na.rm = TRUE
  ) |> 
    round(
      digits = 2
    ) 
  prop_self_funded_range * 100
}
```

```{r example-get_prop_self_funded_range}
load_projects_data("fr") |> 
  get_prop_self_funded_range()
```

```{r tests-get_prop_self_funded_range}
test_that("get_prop_self_funded_range() yield well formed range in FR", {
  projects_data_sf <- load_projects_data("fr") 
  budget_range <- get_prop_self_funded_range(projects_data_sf)
  expect_length(
    budget_range,
    2
  )
  expect_type(
    budget_range,
    "double"
  )
})
test_that("get_prop_self_funded_range() yield well formed range in DE", {
  projects_data_sf <- load_projects_data("de") 
  budget_range <- get_prop_self_funded_range(projects_data_sf)
  expect_length(
    budget_range,
    2
  )
  expect_type(
    budget_range,
    "double"
  )
})
```
  
# Get cantons main organisation

    
```{r function-get_cantons_main_org}
#' @noRd
get_cantons_main_org <- function(
    projects_data_sf  
) {
  cantons_main_org <- unique(projects_data_sf[["id_canton"]])
  names(cantons_main_org) <- gsub(
    pattern = "^CH\\.",
    replacement = "",
    cantons_main_org 
  )
  return(cantons_main_org)
}
```
  
```{r example-get_cantons_main_org}
load_projects_data("fr") |> 
get_cantons_main_org()
```
  
```{r tests-get_cantons_main_org}
test_that("get_cantons_main_org() yields well-formed vector in FR", {
  projects_data_sf <- load_projects_data("fr") 
  cantons_main_org <- get_cantons_main_org(projects_data_sf)
  expect_type(
    cantons_main_org,
    "character"
  )
  # No CH prefix
  expect_true(
    all(
      !grepl(
        pattern = "^CH\\.",
        names(cantons_main_org)
      )
    )
  )
  # No dupplicated canton id
  expect_equal(
    length(cantons_main_org),
    length(unique(cantons_main_org))
  )
})

test_that("get_cantons_main_org() yields well-formed vector in DE", {
  projects_data_sf <- load_projects_data("de") 
  cantons_main_org <- get_cantons_main_org(projects_data_sf)
  expect_type(
    cantons_main_org,
    "character"
  )
  # No CH prefix
  expect_true(
    all(
      !grepl(
        pattern = "^CH\\.",
        names(cantons_main_org)
      )
    )
  )
  # No dupplicated canton id
  expect_equal(
    length(cantons_main_org),
    length(unique(cantons_main_org))
  )
})
```
  
  

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_filter_project_data.Rmd", 
  vignette_name = NA,
  overwrite = TRUE,
  check = FALSE
)
```

