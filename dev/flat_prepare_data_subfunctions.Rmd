---
title: "Prepare data - subfunctions"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(readxl)
library(here)
library(tools)
library(readr)
library(dplyr)
library(tidygeocoder)
library(sf)
library(glue)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Import the raw projects data with `import_raw_data()`

```{r function-import_raw_data}
#' Import the raw data
#' 
#' @param name_raw_file Character. Name of the raw data file.
#' @param pkg_dir Character. Path to the package.
#' 
#' @importFrom readxl read_excel
#' @importFrom tools file_ext
#' @importFrom glue glue
#' 
#' @return A tibble corresponding to raw data
#' 
#' @noRd
import_raw_data <- function(
    name_raw_file = "PGV.xlsx",
    pkg_dir = system.file(package = "observatoire")
) {
  
  raw_data_path <- file.path(
    pkg_dir,
    "data-projects-raw", 
    name_raw_file
  )
  
  if (isFALSE(file.exists(raw_data_path))) {
    stop(glue("There is no file called {name_raw_file} in /data-projects-raw"))
  }
  
  if (isFALSE(file_ext(name_raw_file) == "xlsx")) {
    stop("The raw file must be an xlsx file")
  }
  
  read_excel(
    path = raw_data_path
  )
  
}
```

```{r example-import_raw_data}
# Import the raw data
import_raw_data()
```

```{r tests-import_raw_data}
test_that("Test that the import of the raw data is ok", {
  
  # Create a temp folder with data-projects-raw subfolder and save a toy object inside
  my_temp_dir <- tempfile("test-import-data")
  dir.create(my_temp_dir)
  dir.create(file.path(my_temp_dir, "data-projects-raw"))
  
  writexl::write_xlsx(
    x = iris[1:2, ], 
    path = file.path(my_temp_dir, "data-projects-raw", "iris.xlsx")
  )
  
  write.csv(
    x = iris[1:2, ], 
    file = file.path(my_temp_dir, "data-projects-raw", "iris.csv")
  )
  
  #' @description Testing that there is no error if the xlsx data exists
  expect_error(
    res_iris_import <- import_raw_data(
      name_raw_file = "iris.xlsx",
      pkg_dir = my_temp_dir
    ), regexp = NA
  )
  
  #' @description Testing that the object is the expected one
  expect_equal(
    object = res_iris_import |> 
      dplyr::mutate(
        dplyr::across(
          everything(),
          as.character
        )),
    expected = tibble::as_tibble(iris[1:2, ]) |> 
      dplyr::mutate(
        dplyr::across(
          everything(),
          as.character
        ))
  )
  
  #' @description Testing that there is an error if the data does not exist
  expect_error(
    import_raw_data(
      name_raw_file = "notexists.xlsx",
      pkg_dir = my_temp_dir
    )
  )
  
  #' @description Testing that there is an error if the data is not a xlsx file
  expect_error(
    import_raw_data(
      name_raw_file = "iris.csv",
      pkg_dir = my_temp_dir
    )
  )
  
  unlink(
    my_temp_dir, 
    recursive = TRUE
  )
  
})
```

# Add the proper colums names to the projects data with `add_col_raw_data()`

```{r function-add_col_raw_data}
#' Add the proper colums names to the projects data
#' 
#' @param data Tibble. Raw data about projects.
#' @param dic_variables Tibble. Variables dictionaries. Mainly used for examples and unit testing purpose.
#' 
#' @importFrom readr read_csv2
#' 
#' @return The raw data about the projects with the good columns names.
#'
#' @noRd
add_col_raw_data <- function(
    data,
    dic_variables = NULL
){
  
  # Import the variables dictionary saved in the package
  if (is.null(dic_variables)) {
    dic_variables <- read_csv2(
      system.file(
        "data-dic", 
        "dic_variables.csv", 
        package = "observatoire"
      ),
      show_col_types = FALSE
    )
  }
  
  # Check if all columns are present
  all_expected_columns_are_present <- all(sort(colnames(data)) == sort(dic_variables$de))
  if (isFALSE(all_expected_columns_are_present)) {
    stop(
      paste(
        "The columns in the raw projects data file are not the expected ones.",
        "Please, make sure that the columns are those described in the file dic_variables.csv.",
        sep = "\n"
      )
    )
  }
  
  # Replace german column names with the names of the variables
  colnames(data) <- dic_variables$name_variable[
    match(
      dic_variables$de, 
      names(data)
    )
  ]
  
  return(data)
  
}
```

```{r example-add_col_raw_data}
# Load the toy datasets
data("toy_data_pgv")
data("toy_dic_variables")

# Add the good columns names
toy_data_pgv |> 
  add_col_raw_data(
    dic_variables = toy_dic_variables
  )
```

```{r tests-add_col_raw_data}
test_that("Test that the addition of the variables names is ok", {
  
  # Load the raw data
  data("toy_data_pgv")
  
  # Load the variables dictionary
  data("toy_dic_variables")

  # Add colnames
  raw_data_with_colnames <- add_col_raw_data(
    data = toy_data_pgv,
    dic_variables = toy_dic_variables
  )
  
  #' @description Testing that the colnames are the expected ones
  expect_equal(
    object = sort(colnames(raw_data_with_colnames)), 
    expect = sort(toy_dic_variables$name_variable)
  )
  
  colnames(raw_data_with_colnames) <- colnames(toy_data_pgv)
  
  #' @description Testing that the data is not modified
  expect_equal(
    object = raw_data_with_colnames, 
    expect = toy_data_pgv
  )
  
  colnames(toy_data_pgv)[1] <- "mistake"
  #' @description Testing that there is an error if columns are not the expected ones
  expect_error(
    add_col_raw_data(
      data = toy_data_pgv
    )
  )
  
})
```

# Clean the raw projects data with `clean_raw_data()`

```{r function-clean_raw_data}
#' Clean the raw projects data
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#' 
#' @importFrom dplyr mutate across
#' @importFrom tidyselect contains
#' 
#' @return A tibble with clean data.
#' 
#' @noRd
clean_raw_data <- function(
    data
){
  
  # Remove the first row containing some French column names
  if (data[1, 1] == "Titre") {
    data <- data[-1, ] 
  }
  
  # Convert to digital format
  ## Standardize thousand separators in budget columns
  data_standardized_thousand_sep <- data |> 
    mutate(
      across(
        contains("budget"),
        ~ gsub("^CHF\\s+|\\\'", "", .x)
      )
    )
  
  ## Convert to digital format
  clean_data <- data_standardized_thousand_sep |>
    mutate(
      across(
        contains("budget"),
        as.numeric
      )
    )
  
  return(clean_data)
  
}
```

```{r example-clean_raw_data}
# Load the toy datasets
data("toy_data_pgv")
data("toy_dic_variables")

toy_data <- toy_data_pgv |> 
  add_col_raw_data(
    dic_variables = toy_dic_variables
  )

# Clean the data
toy_data |> 
  clean_raw_data()
```

```{r tests-clean_raw_data}
test_that("Test that the cleaning of the raw data is ok", {
  
  data("toy_data_pgv")

  clean_data <- toy_data_pgv |>
    add_col_raw_data() |>
    clean_raw_data()
  
  #' @description Testing that there is not more issue with French word in the first line
  expect_false(
    object = (clean_data[1, 1] == "Titre")
  )
  
  #' @description Testing that there is not more issue with the thousand sep
  expect_equal(
    object = clean_data |>
      dplyr::filter(
        dplyr::if_any(
          tidyselect::starts_with("budget"),
          ~ grepl("^CHF|\\\'", .x))) |>
      nrow(), 
    expected = 0
  )
  
})
```

# Get the coordinates of the principale organization with `get_coord_main_resp_orga()`

```{r function-get_coord_main_resp_orga}
#' Get the coordinates of the principale organization
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#' @param cantons_sf Sf data. Cantons geometry. Mainly used for examples and unit testing purpose.
#'
#' @importFrom tidygeocoder geocode
#' @importFrom dplyr mutate select filter
#' @importFrom glue glue
#' @importFrom sf st_read st_contains st_point st_union st_as_sf
#' @importFrom purrr map_lgl
#' 
#' @return A tibble with a column with the coordinates of the principale organization.
#' 
#' @noRd
get_coord_main_resp_orga <- function(
    data,
    cantons_sf = NULL
){
  
  # Check if some cities are missing
  nb_missing_cities <- data |> 
    filter(is.na(city_code_main_resp_orga)) |> 
    nrow()
  
  if (nb_missing_cities > 0) {
    message(
      glue(
        "{nb_missing_cities} project.s is.are not associated to a city.",
        "Please correct the problem before restarting the data preparation workflow,",
        "or this.these project.s will not be displayed on the observatory map.",
        .sep = "\n"
      )
    )
  }
  
  # Get the GPS coordinates
  data_with_long_lat <- data |> 
    mutate(
      country = "Switzerland"
    ) |> 
    geocode(
      city = city_code_main_resp_orga, 
      postalcode = zip_code_main_resp_orga,
      country = country,
      method = "osm", 
      lat = latitude , 
      long = longitude
    ) |> 
    select(- country)
  
  # Create sf points
  data_with_coord <- data_with_long_lat |>
    st_as_sf(
      coords = c("longitude", "latitude"),
      crs = 4326, 
      remove = FALSE,
      na.fail = FALSE
    )
  
  # Check if the points are in Switzerland
  if (is.null(cantons_sf)) {
    cantons_sf <- read_cantons_sf()
  }
  
  switzerland_sf <- st_union(
    x = cantons_sf
  )
  
  check_is_in_switzerland <- data_with_coord |> 
    filter(!is.na(longitude) & !is.na(latitude)) |> 
    st_contains(
      x = switzerland_sf,
      y = _,
      sparse = FALSE
    ) |> 
    as.logical()
  
  
  if (any(isFALSE(check_is_in_switzerland))) {
    stop(
      paste(
        "There is an issue in the geocoding of the principale organisation.",
        "Some points that have been found are not in Switzerland.",
        sep = "\n"
      )
    )
  }
  
  return(data_with_coord)
  
}
```

```{r example-get_coord_main_resp_orga}
# Load the toy datasets
data("toy_data_pgv")
data("toy_dic_variables")
data("toy_cantons_sf")

toy_data <- toy_data_pgv |> 
  add_col_raw_data(
    dic_variables = toy_dic_variables
  ) |> 
  clean_raw_data()

# Geocode the principale organisation of the project
toy_data |> 
  get_coord_main_resp_orga(
    cantons_sf = toy_cantons_sf
  )
```

```{r tests-get_coord_main_resp_orga}
test_that("Test that the geocoding of the data is ok", {
  
  toy_data <-
    structure(
      list(
        city_code_main_resp_orga = c(
          "Z\u00fcrich",
          "Sion",
          "St. Gallen",
          NA,
          "Le Cerneux-Veusil",
          "Gen\u00e8ve"
        ), 
        zip_code_main_resp_orga = c(
          "8000",
          "1950",
          "9000",
          NA,
          "2345",
          "1201"
        )
      ),
      row.names = c(NA,
                    -6L),
      class = c("tbl_df", "tbl", "data.frame")
    )

  #' @description Testing that there is a message if there is an issue
  expect_message(
    res_geocode <- get_coord_main_resp_orga(
      data = toy_data,
      cantons_sf = toy_cantons_sf
    ),
    regexp = "1 project.s is.are not associated to a city."
  )
  
  #' @description Testing that there is no error is an usual situation
  expect_error(
    res_geocode <- get_coord_main_resp_orga(
      data = toy_data,
      cantons_sf = toy_cantons_sf
    ),
    regexp = NA
  )
  
})
```

# Get the canton of the principale organization with `get_canton_main_resp_orga()`

```{r function-get_canton_main_resp_orga}
#' Get the canton of the principale organization
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#' @param cantons_sf Sf data. Cantons geometry. Mainly used for examples and unit testing purpose.
#' 
#' @importFrom dplyr filter mutate select left_join rename distinct
#' @importFrom glue glue
#' @importFrom sf st_read st_intersects st_as_sf st_join
#' @importFrom purrr map_df 
#' @importFrom tibble as_tibble tibble
#' 
#' 
#' @return A tibble with the name of the canton
#' 
#' @noRd
get_canton_main_resp_orga <- function(
    data, 
    cantons_sf = NULL
){
  
  # Check if some GPS points are missing
  nb_missing_gps_points <- data |> 
    filter(is.na(longitude) | is.na(latitude)) |> 
    nrow()
  
  if (nb_missing_gps_points > 0) {
    message(
      glue(
        "{nb_missing_gps_points} project.s is.are not associated to a GPS point.",
        "Please correct the problem before restarting the data preparation workflow,",
        "or this.these project.s will not be displayed on the observatory map.",
        .sep = "\n"
      )
    )
  }
  
  # Detect the id of the cantons
  if (is.null(cantons_sf)) {
    cantons_sf <- read_cantons_sf()
  }
  
  data_with_coord <- data |>
    select(short_title, geometry)
  
  data_with_id_canton <- st_join(
    x = data_with_coord, 
    y = select(cantons_sf, HASC_1)
  ) |> 
    rename(
      id_canton = HASC_1
    )
  
  # Add the canton to the raw data
  data_with_canton <- st_join(
    x = data, 
    y = data_with_id_canton,
    suffix = c("", "extra")
  ) |> 
    select(-short_titleextra) |> 
    distinct()
  
  # Check if all cantons have been found
  nb_canton_not_found <- data_with_canton |> 
    filter(!is.na(longitude) & !is.na(latitude)) |> 
    filter(is.na(id_canton)) |> 
    nrow()
  
  if (nb_canton_not_found > 0) {
    stop(
      glue(
        "{nb_canton_not_found} project.s is.are not associated to a canton.",
        "Please correct the problem before restarting the data preparation workflow,",
        "or this.these project.s will not be displayed on the observatory map.",
        .sep = "\n"
      )
    )
  }
  
  return(data_with_canton)
  
}
```

```{r example-get_canton_main_resp_orga}
# Load the toy datasets
data("toy_data_pgv")
data("toy_dic_variables")
data("toy_cantons_sf")

toy_data <- toy_data_pgv |> 
  add_col_raw_data(
    dic_variables = toy_dic_variables
  ) |> 
  clean_raw_data() |> 
  get_coord_main_resp_orga(
    cantons_sf = toy_cantons_sf
  )

# Geocode the principale organisation of the project
toy_data |> 
  get_canton_main_resp_orga(
    cantons_sf = toy_cantons_sf
  )
```

```{r tests-get_canton_main_resp_orga}
test_that("Test that the detection of the canton is ok", {
  
  toy_data <-
    structure(
      list(
        short_title = c(
          "1+1=3  PGV03.038",
          "Action Diab\u00e8te PGV01.057",
          "Angeh\u00f6rigen-Expert/innen PGV03.078",
          "DZ SUCHT",
          "EMIA"
        ),
        longitude = c(8.5410422,
                      7.3588795, 7.4521749, NA, 6.957368),
        latitude = c(47.3744489,
                     46.2311749, 46.9484742, NA, 47.184604),
        geometry = structure(
          list(
            structure(c(8.5410422, 47.3744489), class = c("XY", "POINT",
                                                          "sfg")),
            structure(c(7.3588795, 46.2311749), class = c("XY",
                                                          "POINT", "sfg")),
            structure(c(7.4521749, 46.9484742), class = c("XY",
                                                          "POINT", "sfg")),
            structure(c(NA_real_, NA_real_), class = c("XY",
                                                       "POINT", "sfg")),
            structure(c(6.957368, 47.184604), class = c("XY",
                                                        "POINT", "sfg"))
          ),
          class = c("sfc_POINT", "sfc"),
          precision = 0,
          bbox = structure(
            c(
              xmin = 6.957368,
              ymin = 46.2311749,
              xmax = 8.5410422,
              ymax = 47.3744489
            ),
            class = "bbox"
          ),
          crs = structure(
            list(input = "EPSG:4326", wkt = "GEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]"),
            class = "crs"
          ),
          n_empty = 1L
        )
      ),
      row.names = c(NA,
                    -5L),
      sf_column = "geometry",
      agr = structure(
        c(
          short_title = NA_integer_,
          longitude = NA_integer_,
          latitude = NA_integer_
        ),
        class = "factor",
        levels = c("constant",
                   "aggregate", "identity")
      ),
      class = c("sf", "tbl_df", "tbl", "data.frame")
    )
  
  # Load the toy cantons geometry
  data("toy_cantons_sf")
  
  #' @description Testing that there is a message if there is an issue
  expect_message(
    get_canton_main_resp_orga(
      data = toy_data, 
      cantons_sf = toy_cantons_sf
    ), 
    regexp = "1 project.s is.are not associated to a GPS point"
  )
  
  #' @description Testing that there is no error in an usual case
  expect_error(
    res_toy_data <- get_canton_main_resp_orga(
      data = toy_data, 
      cantons_sf = toy_cantons_sf
    ), 
    regexp = NA
  )
  
  #' @description Testing that the feature provide the expected output
  expect_equal(
    object = res_toy_data$id_canton,
    expected = c(
      "CH.ZH", 
      "CH.VS", 
      "CH.BE", 
      NA, 
      "CH.BE"
    )
  )
  
})
```

# Get the id of the cantons influenced with `get_id_cantons_influenced()`

```{r function-get_id_cantons_influenced}
#' Get the id of the cantons influenced
#' 
#' @param data Tibble. Raw data about projects.
#' @param dic_cantons Tibble. Canton dictionary. Mainly used for examples and unit testing purpose.
#' 
#' @importFrom tidyr separate_rows nest
#' @importFrom dplyr select pull distinct left_join group_by ungroup mutate
#' @importFrom glue glue glue_collapse
#' @importFrom sf st_drop_geometry
#' @importFrom readr read_csv
#' 
#' @return A tibble with a column geo_range_id with te tid of the canton
#' 
#' @noRd
get_id_cantons_influenced <- function(
    data, 
    dic_cantons = NULL
  ){
  
  # Import the variables dictionary saved in the package
  if (is.null(dic_cantons)) {
    dic_cantons <- read_csv(
      system.file(
        "data-dic", 
        "dic_cantons.csv", 
        package = "observatoire"
      ), 
      show_col_types = FALSE
    )
  }
  
  # Check if all cantons in data are present in the dictionary
  data_with_separate_cantons <- data |> 
    mutate(
      geo_range = ifelse(
        is.na(geo_range), 
        "Noch offen", 
        geo_range
      )
    ) |> 
    separate_rows(
      geo_range,
      sep = ",*\r\n"
  ) 
  
  cantons_in_data <- data_with_separate_cantons |> 
    filter(!is.na(geo_range)) |> 
    distinct(
      geo_range
    ) |> 
    pull()
  
  cantons_in_dic <- dic_cantons |> 
    select(
      de
    ) |> 
    pull()
  
  check_all_cantons_in_dic <- cantons_in_data %in% cantons_in_dic
  names(check_all_cantons_in_dic) <- cantons_in_data
  
  if (isFALSE(all(check_all_cantons_in_dic))) {
    
    vec_cantons_absent <- glue_collapse(
      names(
        check_all_cantons_in_dic[check_all_cantons_in_dic == FALSE]
      ),
      sep = ", "
    )
    
    stop(
      glue(
        "Some cantons present in the Reichweite column of the raw data are not present",
        "in the dic_cantons.csv dictionary file",
        "Please check the following cantons before to try again to prepare the data",
        {vec_cantons_absent}, 
        .sep = "\n"
      )
    )
  }
    
  # Get the ID of the cantons
  data_with_separate_id_cantons <- left_join(
    data_with_separate_cantons, 
    dic_cantons |> 
      select(
        de, 
        id
      ),
    by = c("geo_range" = "de")
  )
  
  # Sep the ID with ,
  data_with_id_cantons <- data_with_separate_id_cantons |> 
    st_drop_geometry() |> 
    select(short_title, id) |> 
    group_by(
      short_title
    ) |> 
    nest(
      geo_range_id = id
    ) |> 
    mutate(
      geo_range_id = paste(
        unlist(
          geo_range_id
        ), 
        collapse = ", "
      )
    ) |> 
    ungroup()
  
  # Combine everything
  data_with_id_cantons <- left_join(
    data, 
    data_with_id_cantons, 
    by = "short_title"
  )
  
  return(
    data_with_id_cantons
  )
  
}
```
  
```{r example-get_id_cantons_influenced}
# Load the toy datasets
data("toy_data_pgv")
data("toy_dic_cantons")
data("toy_dic_variables")

toy_data <- toy_data_pgv |> 
  add_col_raw_data(
    dic_variables = toy_dic_variables
  ) |> 
  clean_raw_data()

# Get the id of the cantons influenced
toy_data |> 
  get_id_cantons_influenced(
    dic_cantons = toy_dic_cantons
  ) |> 
  select(
    short_title,
    geo_range_id
  )
```
  
```{r tests-get_id_cantons_influenced}
test_that("Test that the detection of the id of the cantons influenced is ok", {
  
  data("toy_data_pgv")
  data("toy_dic_cantons")
  data("toy_dic_variables")
  
  toy_data <- toy_data_pgv |>
    add_col_raw_data(
      dic_variables = toy_dic_variables
    ) |>
    clean_raw_data()
  
  nb_cantons_geo_range <- toy_data |> 
    mutate(
      geo_range = lengths(stringr::str_split(geo_range, ","))
    ) |> pull(geo_range)
  
  #' @description Testing that the detection is ok
  expect_error(
    res_id_cantons <- get_id_cantons_influenced(
      data = toy_data,
      dic_cantons = toy_dic_cantons
    ), 
    regexp = NA
  )
  
  nb_cantons_geo_range_id <- res_id_cantons |> 
    mutate(
      geo_range_id = lengths(stringr::str_split(geo_range_id, ","))
    ) |> pull(geo_range_id)
    
  #' @description Testing that the number of cantons detected is ok
  expect_equal(
    object = nb_cantons_geo_range_id, 
    expected = nb_cantons_geo_range
  )
  
})
```
  

# Get the number of cantons influenced with `get_nb_cantons_influenced()`

```{r function-get_nb_cantons_influenced}
#' Get the number of cantons influenced
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#' 
#' @importFrom dplyr mutate
#' 
#' @return A tibble with a column with the number of cantons influenced
#' 
#' @noRd
get_nb_cantons_influenced <- function(
    data
    ){
  
  data |> 
    mutate(
      nb_cantons_influenced = lengths(gregexpr(
          ",", 
          geo_range
        )
    ) + 1) 
  
}
```
  
```{r example-get_nb_cantons_influenced}
# Load the toy datasets
data("toy_data_pgv")
data("toy_dic_variables")

raw_data <- toy_data_pgv |> 
  add_col_raw_data(
    dic_variables = toy_dic_variables
  ) |> 
  clean_raw_data()

# Get the number of cantons influenced
raw_data |> 
  get_nb_cantons_influenced() |> 
  select(geo_range, nb_cantons_influenced)
```
  
```{r tests-get_nb_cantons_influenced}
test_that("Test that the computation of the nb of cantons is ok", {
  
  toy_data <-
    structure(
      list(
        geo_range = c(
          "Aargau,\r\nSt. Gallen",
          "Wallis",
          "Appenzell Ausserrhoden,\r\nAppenzell Innerrhoden,\r\nBasel-Landschaft,\r\nBasel-Stadt,\r\nBern,\r\nGenf,\r\nLuzern,\r\nNidwalden,\r\nObwalden,\r\nSt. Gallen,\r\nThurgau,\r\nWaadt,\r\nZ\u00fcrich",
          "Z\u00fcrich"
        )
      ),
      row.names = c(NA, -4L),
      class = c("tbl_df", "tbl",
                "data.frame")
    )
  
  res_nb_cantons_influenced <- toy_data |> 
    get_nb_cantons_influenced()
  
  #' @description Testing that the feature provide the expected output
  expect_equal(
    object = res_nb_cantons_influenced$nb_cantons_influenced,
    expected = c(2, 2, 13, 2)
  )
  
})
```
  
# Get the proportion of the budget for GFCH, principale organization and third party with `get_prop_budget()`

```{r function-get_prop_budget}
#' Get the proportion of the budget for GFCH, principale organization and third party
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#' 
#' @importFrom dplyr mutate across
#' @importFrom tidyselect starts_with
#' 
#' @return A tibble with 3 columns about the proportion of the budget paid by each actor
#' 
#' @noRd
get_prop_budget <- function(
    data
    ){
  
  data |> 
    mutate(
      across(
        starts_with("budget_"), 
        ~ .x / total_budget, 
        .names = "prop_{.col}"
      )
    )
  
}
```
  
```{r example-get_prop_budget}
# Load the toy datasets
data("toy_data_pgv")
data("toy_dic_variables")

# Import the raw data and perform the first preparations
raw_data <- toy_data_pgv |> 
  add_col_raw_data(
    dic_variables = toy_dic_variables
  ) |> 
  clean_raw_data()

# Get the proportion of the budget for GFCH, principale organization and third party
raw_data |> 
  get_prop_budget()
```
  
```{r tests-get_prop_budget}
test_that("Test that the computation of the prop of the budget is ok", {
  
  toy_data <-
    structure(
      list(
        budget_gfch = c(2e+05, 2e+06, 1500000, 182635),
        budget_orga = c(25000, 1714500, 160346, 45000),
        budget_third_party = c(361720,
                               380000, 1500000, 20000),
        total_budget = c(586720, 4094500,
                         3160346, 247635)
      ),
      row.names = c(NA, -4L),
      class = c("tbl_df",
                "tbl", "data.frame")
    )
  
  res_prop_budget <- toy_data |> 
    get_prop_budget() |> 
    dplyr::mutate(
      sum_prop_budget = 
        prop_budget_gfch + 
        prop_budget_third_party + 
        prop_budget_orga
    )
  
  #' @description Testing that the sum of all the proportion equals 1
  expect_true(
    object = all(res_prop_budget$sum_prop_budget == 1)
  )
  
})
```
  
# Translate the data (values in the table) in FR and DE with `translate_values_in_data()`

```{r function-translate_values_in_data}
#' Translate the data (values in the table) in FR and DE
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#' 
#' @return A list of 2 tibbles (FR and DE)
#' 
#' @noRd
translate_values_in_data <- function(
    data, 
    dic_values = NULL, 
    cols_to_translate, 
    sep = ",*\r\n|, |;"
    ){
  
  # Import the values dictionary saved in the package
  if (is.null(dic_values)) {
    dic_values <- read_csv2(
      system.file(
        "data-dic", 
        "dic_values.csv", 
        package = "observatoire"
      ),
      show_col_types = FALSE
    )
  }
  
  # Translate the data in FR
  col_to_translate <- cols_to_translate[2]
  language <- "fr"
  
  data_values_translated <- data |> 
    rename(
      "col_to_translate" = col_to_translate
      ) |> 
    select(short_title, col_to_translate) |> 
    separate_rows(
      col_to_translate, 
      sep = sep
    ) |> 
    left_join(
      dic_values |> 
        select(value, language) |> 
        rename("language" = language), 
      by = c("col_to_translate" = "value")
    ) |> 
    group_by(
      short_title
    ) |> 
    mutate(
      col_translated = paste(
        language, 
        collapse = ", "
      )
    ) |> 
    select(
      short_title, 
      col_translated
      ) |> 
    distinct()
  
  data_translated <- data |> 
    left_join(
      data_values_translated, 
      by = "short_title"
    ) |> 
    select(- col_to_translate)
  
  colnames(data_translated)[
    which(colnames(data_translated) == "col_translated")
  ] <- col_to_translate
  

  
  #TODO
  list(
    data_fr = data, 
    data_de = data
  )
    
}
```
  
```{r example-translate_values_in_data}
# Load the toy datasets
data("toy_data_pgv")
data("toy_dic_variables")
data("toy_dic_values")

# Import the raw data and perform the first preparations
raw_data <- toy_data_pgv |> 
  add_col_raw_data(
    dic_variables = toy_dic_variables
  ) |> 
  clean_raw_data()

# Get the translated data in FR and DE
raw_data |> 
  translate_values_in_data()

data = raw_data
dic_values = toy_dic_values
cols_to_translate = c("status", "topic", "risk_factors")
```
  
```{r tests-translate_values_in_data}
test_that("Test that the translation of the data is ok", {
  #TODO
})
```

# Save the prepared data (FR and DE versions) with `save_projects_data()`

```{r function-save_projects_data}
#' Save the prepared data (FR and DE versions) as .rds objects in the package
#' 
#' @param list_data_fr_de List. With 2 tibbles corresponding to data in FR and data in DE.
#' @param pkg_dir Character. Path to the package.
#' 
#' @importFrom purrr walk
#' 
#' @return Nothing, used for side effect. Save 2 rds files in the package.
#' 
#' @noRd
save_projects_data <- function(
    list_data_fr_de, 
    pkg_dir = system.file(package = "observatoire")
    ){
  
  # Check that the list contains 2 tibbles (FR and DE)
  data_fr_and_de_in_names <- all(
    c("data_fr", "data_de") %in% names(list_data_fr_de)
  )
  
  if (isFALSE(data_fr_and_de_in_names)) {
    stop(
      paste(
        "The object to be saved does not contain FR and DE data",
        "Please check the origin of this issue",
        sep = "\n"
      )
    )
  }
  
  # Save FR data
  saveRDS(
    object = list_data_fr_de$data_fr, 
    file = file.path(
      pkg_dir, 
      "data-projects",
      "projects_fr.rds"
    )
  )
  
  # Save DE data
  saveRDS(
    object = list_data_fr_de$data_de, 
    file = file.path(
      pkg_dir, 
      "data-projects",
      "projects_de.rds"
    )
  )
  
  # Print a message about the time of modification
  available_files_in_data <- list.files(
    file.path(
      pkg_dir, 
      "data-projects"
    )
  )
  
  c("projects_fr.rds", "projects_de.rds") |> 
    walk(
      function(.x){
        if (isTRUE(.x %in% available_files_in_data)) {
          message(
            glue(
              "{.x} has been updated at {file.info(file.path(pkg_dir, \'data-projects\', .x))$mtime}"
              )
            )
          } else {
            message(
              glue(
                "{.x} does not exist in the inst/data folder"
              )
            )
          }
        }
      )
    
}
```
  
```{r example-save_projects_data}
# Load the toy datasets
data("toy_data_pgv")
data("toy_dic_variables")

# Perform the some preparations
list_translated_data <- toy_data_pgv |> 
  add_col_raw_data(
    dic_variables = toy_dic_variables
  ) |> 
  clean_raw_data() |> 
  translate_values_in_data()

# Create a temp folder with data-projects subfolder
my_temp_dir <- tempfile("test-export-data")
dir.create(my_temp_dir)
dir.create(file.path(my_temp_dir, "data-projects"))

# Save rds data in FR and DE
list_translated_data |> 
  save_projects_data(
    pkg_dir = my_temp_dir
  )

# Delete the temp folder
unlink(
  my_temp_dir, 
  recursive = TRUE
)
```
  
```{r tests-save_projects_data}
test_that("Test that the saving of the data in inst works", {
  
  # Create a temp folder with data subfolder
  my_temp_dir <- tempfile("test-export-data")
  dir.create(my_temp_dir)
  dir.create(file.path(my_temp_dir, "data-projects"))
  
  # Create toy lists
  toy_list_ok <- list(
    data_fr = iris, 
    data_de = iris
  )
  
  toy_list_nok <- list(
    data_frzd = iris, 
    data_defe = iris
  )
  
  #' @description Testing that there is an error of the list does not contain the object data_fr and data_de
  expect_error(
    object = save_projects_data(
      toy_list_nok, 
      pkg_dir = my_temp_dir
    ), 
    regexp = "The object to be saved does not contain FR and DE data"
  )
   
  #' @description Testing that the export is ok
  expect_message(
    object = save_projects_data(
      toy_list_ok, 
      pkg_dir = my_temp_dir
    ), 
    regexp = "has been updated at"
  )
  
  unlink(my_temp_dir, recursive = TRUE)
  
})
```

# Prepare the projects data (FR and DE versions) with `prepare_projects_data()`

```{r function-prepare_projects_data}
#' Prepare the projects data in FR and DE to be included in the app as .rds files
#' 
#' @param name_raw_file Character. Name of the raw data file.
#' @param pkg_dir Character. Path to the package (must contain a data-raw folder).
#' @param dic_variables Tibble. Variables dictionaries. Mainly used for examples and unit testing purpose.
#' @param dic_cantons Tibble. Canton dictionary. Mainly used for examples and unit testing purpose.
#' @param cantons_sf Sf data. Cantons geometry. Mainly used for examples and unit testing purpose.
#' 
#' @importFrom glue glue
#' @importFrom here here
#' @importFrom cli cli_process_start cli_alert cli_process_done
#' 
#' @return A list with the projects data in FR and DE.
prepare_projects_data <- function(
    name_raw_file = "PGV.xlsx",
    pkg_dir = system.file(package = "observatoire"),
    dic_variables = NULL, 
    dic_cantons = NULL,
    cantons_sf = NULL
  ){
  
  cli_process_start(
    "Prepare projects_fr.rds and projects_de.rds"
  )

  # Prepare the data and save them
  cli_alert("Import the raw data")
  data_import <- import_raw_data(
    name_raw_file = name_raw_file,
    pkg_dir = pkg_dir
  )
  
  cli_alert("Add the columns")
  data_with_col <- data_import |>
    add_col_raw_data(
      dic_variables = dic_variables
    ) 
  
  cli_alert("Clean the data")
  data_cleaned <- data_with_col |> 
    clean_raw_data()
  
  cli_alert("Add the coordinates of the main organization")
  data_with_coord <- data_cleaned |> 
    get_coord_main_resp_orga(
      cantons_sf = cantons_sf
    ) 
  
  cli_alert("Add the canton of the main organization")
  data_with_cantons <- data_with_coord |> 
    get_canton_main_resp_orga(
      cantons_sf = cantons_sf
    )
  
  cli_alert("Detect the id of the cantons influenced")
  data_with_id_cantons_influenced <- data_with_cantons |> 
    get_id_cantons_influenced(
      dic_cantons = dic_cantons
    )
  
  cli_alert("Add the number of cantons influenced")
  data_with_nb_cantons_influenced <- data_with_id_cantons_influenced |> 
    get_nb_cantons_influenced() 
  
  cli_alert("Add the proportion of the budget")
  data_with_prop_budget <- data_with_nb_cantons_influenced |> 
    get_prop_budget()
  
  cli_alert("Translate the data")
  data_translated <- data_with_prop_budget |> 
    translate_values_in_data() 
  
  cli_alert("Save the data")
  save_projects_data(
    list_data_fr_de = data_translated,
    pkg_dir = pkg_dir
  )
  
  cli_process_done(
    "Prepare projects_fr.rds and projects_de.rds"
  )
  
  return(
    data_translated
  )
 
}
```
  
```{r example-prepare_projects_data, echo=FALSE}
# Load the toy datasets
data("toy_data_pgv")
data("toy_dic_variables")
data("toy_dic_cantons")
data("toy_cantons_sf")

# Create a temp folder with data-projects-raw and ata-projects subfolder
my_temp_dir <- tempfile("test-prepare-data")
dir.create(my_temp_dir)
dir.create(file.path(my_temp_dir, "data-projects-raw"))
dir.create(file.path(my_temp_dir, "data-projects"))

# Save the toy PGV file inside
writexl::write_xlsx(
  toy_data_pgv, 
  file.path(
    my_temp_dir, 
    "data-projects-raw", 
    "toy_PGV.xlsx"
  )
)

# Prepare the data
prepare_projects_data(
  name_raw_file = "toy_PGV.xlsx",
  pkg_dir = my_temp_dir, 
  dic_variables = toy_dic_variables, 
  dic_cantons = toy_dic_cantons,
  cantons_sf = toy_cantons_sf
)

# Delete the tempdir
unlink(my_temp_dir, recursive = TRUE)
```

```{r tests-prepare_projects_data}
test_that("Test that the preparation of the projects data is ok", {

  # Load the toy datasets
  data("toy_data_pgv")
  data("toy_dic_variables")
  data("toy_dic_cantons")
  data("toy_cantons_sf")
  
  # Create a temp folder with data-projects-raw and ata-projects subfolder
  my_temp_dir <- tempfile("test-prepare-data")
  dir.create(my_temp_dir)
  dir.create(file.path(my_temp_dir, "data-projects-raw"))
  dir.create(file.path(my_temp_dir, "data-projects"))
  
  # Save the toy PGV file inside
  writexl::write_xlsx(toy_data_pgv,
                      file.path(my_temp_dir,
                                "data-projects-raw",
                                "toy_PGV.xlsx"))
  
  # Prepare the data
  prepare_projects_data(
    name_raw_file = "toy_PGV.xlsx",
    pkg_dir = my_temp_dir, 
    dic_variables = toy_dic_variables, 
    dic_cantons = toy_dic_cantons,
    cantons_sf = toy_cantons_sf
  )
  
  # Read the created data
  projects_data_fr <- readRDS(
    file.path(
      my_temp_dir,
      "data-projects",
      "projects_fr.rds"
    )
  )
  
  # Perform usage checks on the data
  
  #' @description Testing that the number of rows is the same than in the raw data
  expect_equal(
    object = nrow(projects_data_fr), 
    expected = nrow(toy_data_pgv) - 1 # remove the first line with FR variables names
  )
  
  #' @description Testing that the object contains geometry of points (SF)
  expect_true(
    inherits(projects_data_fr |>
               select(geometry), 
             "sf")
  )
  
  #' @description Testing that the object contains geometry of points with crs = 4326
  expect_equal(
    object = sf::st_crs(
      projects_data_fr |>
        select(geometry)
      )$input, 
    expected = "EPSG:4326"
  )
  
  #' @description Testing that the object contains a column geo_range_id
  expect_true(
    "geo_range_id" %in% colnames(projects_data_fr)
  )
  
  
  # Delete the tempdir
  unlink(my_temp_dir, recursive = TRUE)

})
```

# Prepare the project card for one project and one language with `prepare_one_project_card()`

```{r function-prepare_one_project_card}
#' Prepare the projects cards in DE and FR
#' 
#' @param id_project Character. ID of the project, 'short_title' in data.
#' @param data_projects Tibble. Data projects.
#' @param language Character. Language, 'fr' or 'de'.
#' @param dic_titles_pages Tibble. Title of the pages dictionaries. Mainly used for examples and unit testing purpose.
#' @param pkg_dir Character. Path to the package.
#' 
#' @importFrom htmltools htmlTemplate withTags
#' @importFrom glue glue
#' @importFrom purrr map set_names
#' @importFrom dplyr filter
#' @importFrom lubridate year
#' @importFrom scales number
#' 
#' @return Nothing. Used for side effects. Create the project card.
#' 
#' @noRd
prepare_one_project_card <- function(
    id_project,
    data_projects,
    language = c("de", "fr"),
    dic_titles_pages = NULL,
    pkg_dir = system.file(package = "observatoire")
  ){
  
  language <- match.arg(language)
  
  # Check that the project exists in the raw data
  check_project_in_data <- id_project %in% data_projects[["short_title"]]
  
  if (isFALSE(check_project_in_data)) {
    stop(
      glue(
        "Project {id_project} is not found in {glue(\'projects_{language}.rds\')}",
        "Please check the data before to try again", 
        .sep = "\n")
    )
  }
  
  # Find the translations of the titles
  vec_id_titles_in_project_card <- c(
    "project_start_year_title",
    "project_project_manager_title", 
    "project_main_orga_title", 
    "project_description_title", 
    "project_theme_title", 
    "project_risk_title", 
    "project_budget_title", 
    "project_prop_budget_title")
  
  list_titles <- vec_id_titles_in_project_card |>
    map(
      ~ get_trad_title(
        title_id = .x,
        language = language, 
        dic_titles_pages = dic_titles_pages
      )
    ) |> 
    set_names(
      vec_id_titles_in_project_card
    )

  # Find the parameters about the project
  data_one_project <- data_projects |> 
    filter(short_title == id_project)
  
  short_title_value <- data_one_project[["short_title"]]
  status_value <- data_one_project[["status"]]
  
  possible_col_status <- c(
    "Abschluss" = psch_yellow(), 
    "Umsetzung" = psch_green(), 
    "Abbruch" = psch_bronce()
  )
  
  status_color <- possible_col_status[status_value]
  
  start_year_value <- year(data_one_project[["project_start"]])
  
  project_manager <- data_one_project[["project_support_gfch"]]
  project_manager_url <- 
    paste0(
      "https://promotionsante.ch/fondation/equipe?views_search_api_fulltext=",
      project_manager
    )
  project_manager_value <- glue(
    '<a href=\"{project_manager_url}\" target=\"_blank\">{project_manager}</a>'
  )
    
  main_orga_value <- data_one_project[["main_resp_orga"]]
  
  description_value <- data_one_project[[glue("desc_{language}")]]
  
  if (language == "de") {
    
    more_description_value <- 'Weitere informationen finden sie auf der <a href=\"https://gesundheitsfoerderung.ch/praevention-in-der-gesundheitsversorgung/projektfoerderung/gefoerderte-projekte\" target=\"_blank\">website von Gesundheitf\u00f6rdernung Schweiz</a>'
    
  } else if (language == "fr") {
    
    more_description_value <- 'Vous trouverez des informations compl\u00e9mentaires  sur le <a href=\"https://promotionsante.ch/prevention-dans-le-domaine-des-soins/soutien-de-projets/projets-soutenus\" target=\"_blank\">site de Promotion Sant\u00e9 Suisse</a>'
    
  }
  
  theme_value <- paste0(
    "<li>",
    gsub(
      pattern = ",*\r\n|, ", "</li><li>", 
      data_one_project[["topic"]]
    ),
    "</li>"
  )
  risk_value <- paste0(
    "<li>",
    gsub(
      pattern = ",*\r\n|, ", "</li><li>", 
      data_one_project[["risk_factors"]]
    ),
    "</li>"
  )
    
  budget_value <- number(
    as.numeric(data_one_project[["total_budget"]]), 
    suffix = " CHF"
  )
  
  # Generate the html content
  html_content <- htmlTemplate(
    filename = system.file(
      "data-projects-cards",
      "template_projects_cards.html",
      package = "observatoire"
    ),
    short_title_value = short_title_value,
    status_color = status_color,
    status_value = status_value,
    project_start_year_title = list_titles[["project_start_year_title"]],
    project_project_manager_title = HTML(list_titles[["project_project_manager_title"]]),
    project_main_orga_title = list_titles[["project_main_orga_title"]],
    start_year_value = start_year_value,
    project_manager_value = HTML(project_manager_value),
    main_orga_value = main_orga_value,
    project_description_title = list_titles[["project_description_title"]],
    description_value = description_value,
    more_description_value = HTML(more_description_value),
    project_theme_title = list_titles[["project_theme_title"]],
    theme_value = HTML(theme_value),
    project_risk_title = list_titles[["project_risk_title"]],
    risk_value = HTML(risk_value),
    project_budget_title = list_titles[["project_budget_title"]],
    budget_value = budget_value,
    project_prop_budget_title = list_titles[["project_prop_budget_title"]]
  )
  
  # Save the html file
  clean_id_project <- clean_id_project(
    id_project = id_project
  )
  name_file <- glue("project_card_{clean_id_project}_{language}.html")
  
  file_con <- file.path(
      pkg_dir, 
      "data-projects-cards",
      name_file
    )
  
  writeLines(
    as.character(html_content), 
    file_con
  )

}
```
  
```{r example-prepare_one_project_card}
# Create a temp folder with data-projects-cards subfolder
my_temp_dir <- tempfile("test-create-project-card")
dir.create(my_temp_dir)
dir.create(file.path(my_temp_dir, "data-projects-cards"))
  
file.copy(
  from = app_sys(
    "data-projects-cards", 
    "template_projects_cards.html"
    ), 
  to = file.path(
    my_temp_dir, 
    "data-projects-cards", 
    "template_projects_cards.html"
    )
)

# Load toy dataset
data("toy_dic_titles_pages")

prepare_one_project_card(
  id_project = "1+1=3  PGV03.038", 
  data_projects = read_projects_data(language = "de"),
  language = "de", 
  pkg_dir = my_temp_dir, 
  dic_titles_pages = toy_dic_titles_pages 
)

browseURL(
  file.path(
    my_temp_dir, 
    "data-projects-cards", 
    "project_card_113PGV03038_de.html"
  )
)

prepare_one_project_card(
  id_project = "1+1=3  PGV03.038", 
  data_projects = read_projects_data(language = "fr"),
  language = "fr", 
  pkg_dir = my_temp_dir, 
  dic_titles_pages = toy_dic_titles_pages
)

browseURL(
  file.path(
    my_temp_dir, 
    "data-projects-cards", 
    "project_card_113PGV03038_fr.html"
  )
)

unlink(my_temp_dir, recursive = TRUE)
```
  
```{r tests-prepare_one_project_card}
test_that("Test that the preparation of a project card works", {
  
  data("toy_projects_data_sf")
  data("toy_dic_titles_pages")
  
  # Create a temp folder with data-projects-cards subfolder
  my_temp_dir <- tempfile("test-create-project-card")
  dir.create(my_temp_dir)
  dir.create(file.path(my_temp_dir, "data-projects-cards"))
  
  file.copy(
    from = app_sys(
      "data-projects-cards", 
      "template_projects_cards.html"
    ), 
    to = file.path(
      my_temp_dir, 
      "data-projects-cards", 
      "template_projects_cards.html"
    )
  )
  
  prepare_one_project_card(
    id_project = "1+1=3  PGV03.038",
    data_projects = toy_projects_data_sf,
    language = "de", 
    pkg_dir = my_temp_dir, 
    dic_titles_pages = toy_dic_titles_pages
  )
  
  expect_true(
    file.exists(
      file.path(
         my_temp_dir, 
        "data-projects-cards", 
        "project_card_113PGV03038_de.html"
      )
    )
  )
  
  unlink(my_temp_dir, recursive = TRUE)
  
})
```

# Prepare all the project cards in DE and FR with `prepare_projects_cards()`

```{r function-prepare_projects_cards}
#' Prepare all the project cards in DE and FR
#' 
#' @param data_projects_fr Tibble. Projects data in FR.
#' @param data_projects_de Tibble. Projects data in DE.
#' @param dic_titles_pages Tibble. Title of the pages dictionaries. Mainly used for examples and unit testing purpose.
#' @param pkg_dir Character. Path to the package.
#' 
#' @importFrom dplyr pull
#' @importFrom purrr walk
#' @importFrom glue glue
#' @importFrom cli cli_process_start cli_process_done cli_alert
#' 
#' @return Nothing. Used for side effects. Create the project card.
prepare_projects_cards <- function(
    data_projects_fr = read_projects_data(language = "fr"),
    data_projects_de = read_projects_data(language = "de"),
    dic_titles_pages = NULL,
    pkg_dir = system.file(package = "observatoire")
    ){
  
  cli_process_start(
    "Prepare the projects cards"
  )
  
  cli_alert(
    "Prepare the projects cards"
  )
  
  # Clean everything
  files_in_dir <- list.files(
    file.path(
      pkg_dir, 
      "data-projects-cards"
    )
  )
  files_to_delete <- files_in_dir[
    !(files_in_dir %in% c("projects_cards.css", "template_projects_cards.html"))
  ]
  files_to_delete |> 
    walk(
      ~ unlink(
        file.path(
          pkg_dir, 
          "data-projects-cards", 
          .x
        )
      )
    )
  
  # Get all the id of the projects
  all_id_projects <- data_projects_fr |> pull(short_title)
  
  # Create all cards in FR
  all_id_projects |> 
    walk(
      ~ prepare_one_project_card(
          id_project = .x, 
          language = "fr", 
          data_projects = data_projects_fr,
          dic_titles_pages = dic_titles_pages,
          pkg_dir = pkg_dir
      )
    )
  
  # Create all cards in DE
  all_id_projects |> 
    walk(
      ~ prepare_one_project_card(
          id_project = .x, 
          language = "de", 
          data_projects = data_projects_de,
          dic_titles_pages = dic_titles_pages,
          pkg_dir = pkg_dir
      )
    )
  
  # Print a message about the time of modification
  available_files_in_data <- list.files(
    file.path(
      pkg_dir, 
      "data-projects-cards"
    )
  )
  
  nb_files_fr <- length(grep(
    pattern = "_fr.html", 
    x = available_files_in_data
  ))
  
  nb_files_de <- length(grep(
    pattern = "_de.html", 
    x = available_files_in_data
  ))
  
  if (nb_files_fr != 0 & nb_files_de != 0) {
    
    time_modif <- file.info(
      file.path(
        pkg_dir, 
        'data-projects-cards', 
        available_files_in_data[1]))$mtime
    
    message(
      glue(
        "{nb_files_de} projects cards in DE have been updated at {time_modif}",
        "{nb_files_fr} projects cards in FR have been updated at {time_modif}", 
        .sep = "\n"
        )
      )
    
  } else {
    
    stop(
      "Something went wrong about the preparation of the projects cards"
    )
    
  }
  
  cli_process_done(
    "Prepare the projects cards"
  )
    
}
```
  
```{r example-prepare_projects_cards}
# Load the toy datasets
data("toy_projects_data_sf")
data("toy_dic_titles_pages")

# Keep 2 projects
toy_data <- toy_projects_data_sf[1:2, ]

# Create a temp folder with data-projects-cards subfolder
my_temp_dir <- tempfile("test-create-project-card")
dir.create(my_temp_dir)
dir.create(file.path(my_temp_dir, "data-projects-cards"))
  
file.copy(
  from = system.file(
    "data-projects-cards", 
    "template_projects_cards.html", 
    package = "observatoire"
    ), 
  to = file.path(
    my_temp_dir, 
    "data-projects-cards", 
    "template_projects_cards.html"
    )
)
  
prepare_projects_cards(
  data_projects_fr = toy_data,
  data_projects_de = toy_data,
  dic_titles_pages = toy_dic_titles_pages,
  pkg_dir = my_temp_dir
)

list.files(
  file.path(
    my_temp_dir, 
    "data-projects-cards"
  )
)

unlink(my_temp_dir, recursive = TRUE)
```
  
```{r tests-prepare_projects_cards}
test_that("Test that the preparation of all cards works", {
  
  # Load the toy datasets
  data("toy_projects_data_sf")
  data("toy_dic_titles_pages")
  
  # Keep 2 projects
  toy_data <- toy_projects_data_sf[1:2,]
  
  # Create a temp folder with data-projects-cards subfolder
  my_temp_dir <- tempfile("test-create-project-card")
  dir.create(my_temp_dir)
  dir.create(file.path(my_temp_dir, "data-projects-cards"))
  
  file.copy(
    from = app_sys("data-projects-cards",
                   "template_projects_cards.html"),
    to = file.path(
      my_temp_dir,
      "data-projects-cards",
      "template_projects_cards.html"
    )
  )
  
  prepare_projects_cards(
    data_projects_fr = toy_data,
    data_projects_de = toy_data,
    dic_titles_pages = toy_dic_titles_pages,
    pkg_dir = my_temp_dir
  )
  
  expect_true(
    file.exists(
      file.path(
        my_temp_dir,
        "data-projects-cards",
        "project_card_113PGV03038_de.html"
      )
    )
  )
  
  expect_true(
    file.exists(
      file.path(
        my_temp_dir,
        "data-projects-cards",
        "project_card_113PGV03038_fr.html"
      )
    )
  )
  
  expect_true(
    file.exists(
      file.path(
        my_temp_dir,
        "data-projects-cards",
        "project_card_ActionDiabetePGV01057_de.html"
      )
    )
  )
  
  expect_true(
    file.exists(
      file.path(
        my_temp_dir,
        "data-projects-cards",
        "project_card_ActionDiabetePGV01057_fr.html"
      )
    )
  )
  
  unlink(my_temp_dir, recursive = TRUE)
  
})
```
  
```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_prepare_data_subfunctions.Rmd", 
  vignette_name = NA,
  check = FALSE
)
```
