---
title: "Prepare data - subfunctions"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(readxl)
library(here)
library(tools)
library(readr)
library(dplyr)
library(tidygeocoder)
library(sf)
library(glue)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Import the raw projects data with `import_raw_data()`

```{r function-import_raw_data}
#' Import the raw data
#' 
#' @param name_raw_file Character. Name of the raw data file.
#' @param pkg_dir Character. Path to the package.
#' 
#' @importFrom readxl read_excel
#' @importFrom tools file_ext
#' @importFrom glue glue
#' 
#' @return A tibble corresponding to raw data
#' 
#' @noRd
import_raw_data <- function(
    name_raw_file = "PGV.xlsx",
    pkg_dir = system.file(package = "observatoire")
) {
  
  raw_data_path <- file.path(
    pkg_dir,
    "data-raw", 
    name_raw_file
  )
  
  if (isFALSE(file.exists(raw_data_path))) {
    stop(glue("There is no file called {name_raw_file} in /data-raw"))
  }
  
  if (isFALSE(file_ext(name_raw_file) == "xlsx")) {
    stop("The raw file must be an xlsx file")
  }
  
  read_excel(
    path = raw_data_path
  )
  
}
```

```{r example-import_raw_data}
# Import the raw data
import_raw_data()
```

```{r tests-import_raw_data}
test_that("Test that the import of the raw data is ok", {
  
  # Create a temp folder with data-raw subfolder and save a toy object inside
  my_temp_dir <- tempfile("test-import-data")
  dir.create(my_temp_dir)
  dir.create(file.path(my_temp_dir, "data-raw"))
  
  writexl::write_xlsx(
    x = iris[1:2, ], 
    path = file.path(my_temp_dir, "data-raw", "iris.xlsx")
  )
  
  write.csv(
    x = iris[1:2, ], 
    file = file.path(my_temp_dir, "data-raw", "iris.csv")
  )
  
  #' @description Testing that there is no error if the xlsx data exists
  expect_error(
    res_iris_import <- import_raw_data(
      name_raw_file = "iris.xlsx",
      pkg_dir = my_temp_dir
    ), regexp = NA
  )
  
  #' @description Testing that the object is the expected one
  expect_equal(
    object = res_iris_import |> 
      dplyr::mutate(
        dplyr::across(
          everything(),
          as.character
        )),
    expected = tibble::as_tibble(iris[1:2, ]) |> 
      dplyr::mutate(
        dplyr::across(
          everything(),
          as.character
        ))
  )
  
  #' @description Testing that there is an error if the data does not exist
  expect_error(
    import_raw_data(
      name_raw_file = "notexists.xlsx",
      pkg_dir = my_temp_dir
    )
  )
  
  #' @description Testing that there is an error if the data is not a xlsx file
  expect_error(
    import_raw_data(
      name_raw_file = "iris.csv",
      pkg_dir = my_temp_dir
    )
  )
  
  unlink(
    my_temp_dir, 
    recursive = TRUE
  )
  
})
```

# Add the proper colums names to the projects data with `add_col_raw_data()`

```{r function-add_col_raw_data}
#' Add the proper colums names to the projects data
#' 
#' @param data Tibble. Raw data about projects.
#' 
#' @importFrom readr read_csv2
#' 
#' @return The raw data about the projects with the good columns names.
#'
#' @noRd
add_col_raw_data <- function(
    data
){
  
  # Import the variables dictionary saved in the package
  dic_variables <- read_csv2(
    system.file("dic_variables.csv", package = "observatoire"),
    show_col_types = FALSE
  )
  
  # Check if all columns are present
  all_expected_columns_are_present <- all(sort(colnames(data)) == sort(dic_variables$de))
  if (isFALSE(all_expected_columns_are_present)) {
    stop(
      paste(
        "The columns in the raw projects data file are not the expected ones.",
        "Please, make sure that the columns are those described in the file dic_variables.csv.",
        sep = "\n"
      )
    )
  }
  
  # Replace german column names with the names of the variables
  colnames(data) <- dic_variables$name_variable[
    match(
      dic_variables$de, 
      names(data)
    )
  ]
  
  return(data)
  
}
```

```{r example-add_col_raw_data}
# Import the raw data
raw_projetcs_data <- import_raw_data()

# Add the good columns names
raw_projetcs_data |> 
  add_col_raw_data()
```

```{r tests-add_col_raw_data}
test_that("Test that the addition of the variables names is ok", {
  
  raw_projects_data <- import_raw_data()
  
  # Add colnames
  raw_data_with_colnames <- add_col_raw_data(
    data = raw_projects_data
  )
  
  # Import the variables dictionary saved in the package
  dic_variables <- read_csv2(
    system.file("dic_variables.csv", package = "observatoire"),
    show_col_types = FALSE
  )
  
  #' @description Testing that the colnames are the expected ones
  expect_equal(
    object = sort(colnames(raw_data_with_colnames)), 
    expect = sort(dic_variables$name_variable)
  )
  
  colnames(raw_data_with_colnames) <- colnames(raw_projects_data)
  
  #' @description Testing that the data is not modified
  expect_equal(
    object = raw_data_with_colnames, 
    expect = raw_projects_data
  )
  
  colnames(raw_projects_data)[1] <- "mistake"
  #' @description Testing that there is an error if columns are not the expected ones
  expect_error(
    add_col_raw_data(
      data = raw_projects_data
    )
  )
  
})
```

# Clean the raw projects data with `clean_raw_data()`

```{r function-clean_raw_data}
#' Clean the raw projects data
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#' 
#' @importFrom dplyr mutate across
#' @importFrom tidyselect contains
#' 
#' @return A tibble with clean data.
#' 
#' @noRd
clean_raw_data <- function(
    data
){
  
  # Remove the first row containing some French column names
  if (data[1, 1] == "Titre") {
    data <- data[-1, ] 
  }
  
  # Convert to digital format
  ## Standardize thousand separators in budget columns
  data_standardized_thousand_sep <- data |> 
    mutate(
      across(
        contains("budget"),
        ~ gsub("^CHF\\s+|\\'", "", .x)
      )
    )
  
  ## Convert to digital format
  clean_data <- data_standardized_thousand_sep |>
    mutate(
      across(
        contains("budget"),
        as.numeric
      )
    )
  
  return(clean_data)
  
}
```

```{r example-clean_raw_data}
# Import the raw data and add the good columns names
raw_data <- import_raw_data() |> 
  add_col_raw_data()

# Clean the data
raw_data |> 
  clean_raw_data()
```

```{r tests-clean_raw_data}
test_that("Test that the cleaning of the raw data is ok", {
  
  raw_data <- import_raw_data()
  
  clean_data <- raw_data |>
    add_col_raw_data() |>
    clean_raw_data()
  
  #' @description Testing that there is not more issue with French word in the first line
  expect_false(
    object = (clean_data[1, 1] == "Titre")
  )
  
  #' @description Testing that there is not more issue with the thousand sep
  expect_equal(
    object = clean_data |>
      dplyr::filter(
        dplyr::if_any(
          tidyselect::starts_with("budget"),
          ~ grepl("^CHF|\\'", .x))) |>
      nrow(), 
    expected = 0
  )
  
})
```

# Get the coordinates of the principale organization with `get_coord_main_resp_orga()`

```{r function-get_coord_main_resp_orga}
#' Get the coordinates of the principale organization
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#'
#' @importFrom tidygeocoder geocode
#' @importFrom dplyr mutate select filter
#' @importFrom glue glue
#' @importFrom sf st_read st_contains st_point st_union st_as_sf
#' @importFrom purrr map_lgl
#' 
#' @return A tibble with a column with the coordinates of the principale organization.
#' 
#' @noRd
get_coord_main_resp_orga <- function(
    data
){
  
  # Check if some cities are missing
  nb_missing_cities <- data |> 
    filter(is.na(city_code_main_resp_orga)) |> 
    nrow()
  
  if (nb_missing_cities > 0) {
    message(
      glue(
        "{nb_missing_cities} project.s is.are not associated to a city.",
        "Please correct the problem before restarting the data preparation workflow,",
        "or this.these project.s will not be displayed on the observatory map.",
        .sep = "\n"
      )
    )
  }
  
  data_with_coord <- data |> 
    mutate(
      country = "Switzerland"
    ) |> 
    geocode(
      city = city_code_main_resp_orga, 
      country = country,
      method = "osm", 
      lat = latitude , 
      long = longitude
    ) |> 
    select(- country)
  
  # Check if the points are in Switzerland
  cantons_sf <- st_read(
    dsn = system.file(
      "gadm41_CHE_1.json", 
      package = "observatoire"
    )
  )
  
  switzerland_sf <- st_union(
    x = cantons_sf
  )
  
  check_is_in_switzerland <- data_with_coord |> 
    filter(!is.na(longitude) & !is.na(latitude)) |> 
    st_as_sf(
      coords = c("longitude", "latitude"),
      crs = 4326
    ) |> 
    st_contains(
      x = switzerland_sf,
      y = _,
      sparse = FALSE
    ) |> 
    as.logical()
  
  
  if (any(isFALSE(check_is_in_switzerland))) {
    stop(
      paste(
        "There is an issue in the geocoding of the principale organisation.",
        "Some points that have been found are not in Switzerland.",
        sep = "\n"
      )
    )
  }
  
  return(data_with_coord)
  
}
```

```{r example-get_coord_main_resp_orga}
# Import the raw data and add the good columns names
raw_data <- import_raw_data() |> 
  add_col_raw_data() |> 
  clean_raw_data()

# Geocode the principale organisation of the project
raw_data |> 
  get_coord_main_resp_orga()
```

```{r tests-get_coord_main_resp_orga}
test_that("Test that the geocoding of the data is ok", {
  
  toy_data <-
    structure(
      list(
        city_code_main_resp_orga = c(
          "Zürich",
          "Sion",
          "Bern",
          "Lausanne",
          "St. Gallen",
          NA,
          "Le Cerneux-Veusil",
          "Genève",
          "Aarau",
          "Münsingen"
        )
      ),
      row.names = c(NA,
                    -10L),
      class = c("tbl_df", "tbl", "data.frame")
    )
  
  expect_message(
    res_geocode <- get_coord_main_resp_orga(
      data = toy_data
    ),
    regexp = "1 project.s is.are not associated to a city."
  )
  
  expect_error(
    res_geocode <- get_coord_main_resp_orga(
      data = toy_data
    ),
    regexp = NA
  )
  
})
```

# Get the canton of the principale organization with `get_canton_main_resp_orga()`

```{r function-get_canton_main_resp_orga}
#' Get the canton of the principale organization
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#' 
#' @importFrom dplyr filter mutate select left_join rename
#' @importFrom glue glue
#' @importFrom sf st_read st_intersects st_as_sf st_join
#' @importFrom purrr map_df 
#' @importFrom tibble as_tibble tibble
#' 
#' 
#' @return A tibble with the name of the canton
#' 
#' @noRd
get_canton_main_resp_orga <- function(
    data
){
  
  # Check if some GPS points are missing
  nb_missing_gps_points <- data |> 
    filter(is.na(longitude) | is.na(latitude)) |> 
    nrow()
  
  if (nb_missing_gps_points > 0) {
    message(
      glue(
        "{nb_missing_gps_points} project.s is.are not associated to a GPS point.",
        "Please correct the problem before restarting the data preparation workflow,",
        "or this.these project.s will not be displayed on the observatory map.",
        .sep = "\n"
      )
    )
  }
  
  # Detect the id of the cantons
  cantons_sf <- st_read(
    dsn = system.file(
      "gadm41_CHE_1.json", 
      package = "observatoire"
    ),
    quiet = TRUE
  )
  
  data_with_coord <- data |>
    filter(!is.na(longitude) & !is.na(latitude)) |> 
    select(short_title, longitude, latitude) |> 
    st_as_sf(
      coords = c("longitude", "latitude"),
      crs = 4326
    )
  
  data_with_id_canton <- st_join(
    x = data_with_coord, 
    y = select(cantons_sf, HASC_1)
  ) |> 
    rename(
      id_canton = HASC_1
    )
  
  # Add the canton to the raw data
  data_with_canton <- left_join(
    x = data, 
    y = data_with_id_canton,
    by = "short_title"
  )
  
  # Check if all cantons have been found
  nb_canton_not_found <- data_with_canton |> 
    filter(!is.na(longitude) & !is.na(latitude)) |> 
    filter(is.na(id_canton)) |> 
    nrow()
  
  if (nb_canton_not_found > 0) {
    stop(
      glue(
        "{nb_canton_not_found} project.s is.are not associated to a canton.",
        "Please correct the problem before restarting the data preparation workflow,",
        "or this.these project.s will not be displayed on the observatory map.",
        .sep = "\n"
      )
    )
  }
  
  return(data_with_canton)
  
}
```

```{r example-get_canton_main_resp_orga}
# Import the raw data and perform the first preparations
raw_data <- import_raw_data() |> 
  add_col_raw_data() |> 
  clean_raw_data() |> 
  get_coord_main_resp_orga()

# Geocode the principale organisation of the project
raw_data |> 
  get_canton_main_resp_orga()
```

```{r tests-get_canton_main_resp_orga}
test_that("Test that the detection of the canton is ok", {
  
  toy_data <-
    structure(
      list(
        short_title = c(
          "Starke Familie",
          "StoppSturz",
          "Sturzprävention in der Spitex",
          "WilaDina",
          "Win Back Control PGV01.002",
          "WOPM PGV02.015",
          "Zigzag Plus PGV02.064",
          "FM_ProPCC+"
        ),
        longitude = c(
          8.0444448,
          9.3762397,
          8.7954859,
          7.5631943,
          8.5410422,
          7.4521749,
          6.6327025,
          NA
        ),
        latitude = c(
          47.3927146,
          47.425618,
          46.1695739,
          46.8739775,
          47.3744489,
          46.9484742,
          46.5218269,
          NA
        )
      ),
      row.names = c(NA, -8L),
      class = c("tbl_df", "tbl", "data.frame")
    )
  
  expect_message(
    get_canton_main_resp_orga(
      data = toy_data
    ), 
    regexp = "1 project.s is.are not associated to a GPS point"
  )
  
  expect_error(
    res_toy_data <- get_canton_main_resp_orga(
      data = toy_data
    ), 
    regexp = NA
  )
  
  expect_equal(
    object = res_toy_data$id_canton,
    expected = c(
      "CH.AG", 
      "CH.SG", 
      "CH.TI", 
      "CH.BE", 
      "CH.ZH", 
      "CH.BE", 
      "CH.VD", 
      NA
    )
  )
  
})
```

# Get the number of cantons influenced with `get_nb_cantons_influenced()`

```{r function-get_nb_cantons_influenced}
#' Get the number of cantons influenced
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#' 
#' @importFrom dplyr mutate
#' 
#' @return A tibble with a column with the number of cantons influenced
#' 
#' @noRd
get_nb_cantons_influenced <- function(
    data
    ){
  
  data |> 
    mutate(
      nb_cantons_influenced = lengths(gregexpr(
          ",", 
          geo_range
        )
    ) + 1) 
  
}
```
  
```{r example-get_nb_cantons_influenced}
# Import the raw data and perform the first preparations
raw_data <- import_raw_data() |> 
  add_col_raw_data() |> 
  clean_raw_data()

# Get the number of cantons influenced
raw_data |> 
  get_nb_cantons_influenced() |> 
  select(geo_range, nb_cantons_influenced)
```
  
```{r tests-get_nb_cantons_influenced}
test_that("Test that the computation of the nb of cantons is ok", {
  
  toy_data <-
    structure(
      list(
        geo_range = c(
          "Aargau,\r\nSt. Gallen",
          "Wallis",
          "Appenzell Ausserrhoden,\r\nAppenzell Innerrhoden,\r\nBasel-Landschaft,\r\nBasel-Stadt,\r\nBern,\r\nGenf,\r\nLuzern,\r\nNidwalden,\r\nObwalden,\r\nSt. Gallen,\r\nThurgau,\r\nWaadt,\r\nZürich",
          "Zürich"
        )
      ),
      row.names = c(NA, -4L),
      class = c("tbl_df", "tbl",
                "data.frame")
    )
  
  res_nb_cantons_influenced <- toy_data |> 
    get_nb_cantons_influenced()
  
  expect_equal(
    object = res_nb_cantons_influenced$nb_cantons_influenced,
    expected = c(2, 2, 13, 2)
  )
  
})
```
  
# Get the proportion of the budget for GFCH, principale organization and third party with `get_prop_budget()`

```{r function-get_prop_budget}
#' Get the proportion of the budget for GFCH, principale organization and third party
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#' 
#' @importFrom dplyr mutate across
#' @importFrom tidyselect starts_with
#' 
#' @return A tibble with 3 columns about the proportion of the budget paid by each actor
#' 
#' @noRd
get_prop_budget <- function(
    data
    ){
  
  data |> 
    mutate(
      across(
        starts_with("budget_"), 
        ~ .x / total_budget, 
        .names = "prop_{.col}"
      )
    )
  
}
```
  
```{r example-get_prop_budget}
# Import the raw data and perform the first preparations
raw_data <- import_raw_data() |> 
  add_col_raw_data() |> 
  clean_raw_data()

# Get the proportion of the budget for GFCH, principale organization and third party
raw_data |> 
  get_prop_budget()
```
  
```{r tests-get_prop_budget}
test_that("Test that the computation of the prop of the budget is ok", {
  
  toy_data <-
    structure(
      list(
        budget_gfch = c(2e+05, 2e+06, 1500000, 182635),
        budget_orga = c(25000, 1714500, 160346, 45000),
        budget_third_party = c(361720,
                               380000, 1500000, 20000),
        total_budget = c(586720, 4094500,
                         3160346, 247635)
      ),
      row.names = c(NA, -4L),
      class = c("tbl_df",
                "tbl", "data.frame")
    )
  
  res_prop_budget <- toy_data |> 
    get_prop_budget() |> 
    dplyr::mutate(
      sum_prop_budget = 
        prop_budget_gfch + 
        prop_budget_third_party + 
        prop_budget_orga
    )
  
  expect_true(
    object = all(res_prop_budget$sum_prop_budget == 1)
  )
  
})
```
  
# Translate the data (values in the table) in FR and DE with `translate_values_in_data()`

```{r function-translate_values_in_data}
#' Translate the data (values in the table) in FR and DE
#' 
#' @param data Tibble. Raw data about projects, with the good columns names.
#' 
#' @return A list of 2 tibbles (FR and DE)
#' 
#' @noRd
translate_values_in_data <- function(
    data
    ){
  
  #TODO
  list(
    data_fr = data, 
    data_de = data
  )
    
}
```
  
```{r example-translate_values_in_data}
# Import the raw data and perform the first preparations
raw_data <- import_raw_data() |> 
  add_col_raw_data() |> 
  clean_raw_data()

# Get the translated data in FR and DE
raw_data |> 
  translate_values_in_data()
```
  
```{r tests-translate_values_in_data}
test_that("Test that the translation of the data is ok", {
  #TODO
})
```

# Save the prepared data (FR and DE versions) with `save_projects_data()`

```{r function-save_projects_data}
#' Save the prepared data (FR and DE versions) as .rds objects in the package
#' 
#' @param list_data_fr_de List. With 2 tibbles corresponding to data in FR and data in DE.
#' @param pkg_dir Character. Path to the package.
#' 
#' @return Nothing, used for side effect. Save 2 rds files in the package.
#' 
#' @noRd
save_projects_data <- function(
    list_data_fr_de, 
    pkg_dir = system.file(package = "observatoire")
    ){
  
  # Save FR data
  saveRDS(
    object = list_data_fr_de$data_fr, 
    file = file.path(
      pkg_dir, 
      "projects_fr.rds"
    )
  )
  
  # Save DE data
  saveRDS(
    object = list_data_fr_de$data_de, 
    file = file.path(
      pkg_dir, 
      "projects_de.rds"
    )
  )
    
}
```
  
```{r example-save_projects_data}
# Import the raw data and perform the some preparations
list_translated_data <- import_raw_data() |> 
  add_col_raw_data() |> 
  clean_raw_data() |> 
  translate_values_in_data()

# Save rds data in FR and DE
list_translated_data |> 
  save_projects_data()
```
  
```{r tests-save_projects_data}
test_that("save_projects_data works", {
  expect_true(inherits(save_projects_data, "function")) 
})
```
  
TODO

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_prepare_data_subfunctions.Rmd", 
  vignette_name = NA,
  check = FALSE
)
```

