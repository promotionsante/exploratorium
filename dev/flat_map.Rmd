---
title: "Draw the maps"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  eval=FALSE,
  echo=TRUE
)
```

```{r development, include=FALSE}
library(testthat)
library(sf)
library(leaflet)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

*The aim of this article is to show you how to reproduce the maps printed on the app.*

# Draw the map of filtered projects

To create the map with projects as points, you can use the `draw_map_selected_projects()` function as follows *(here with a toy dataset)*:

```{r function-draw_map_selected_projects}
#' Draw map of selected projects
#' 
#' @param projects_data_sf A sf data.frame containing coordinates of project 
#' main organisation and project `short_title`.
#' 
#' @param zoom_level An integer. The zoom level for the map. Defines
#' default zoom level.
#' 
#' @return A leaflet object.
#' 
#' @importFrom leaflet addCircleMarkers  addPolygons
#' 
#' @export
draw_map_selected_projects <- function(
    projects_data_sf,
    zoom_level = 8
){
  draw_map_base(zoom_level) |> 
    addPolygons(
      data = read_cantons_sf(),
      weight = 1,
      color = psch_blue(),
      fillColor = psch_blue(),
      fillOpacity = 0.3
    ) |>
    addCircleMarkers(
      data = projects_data_sf,
      color = psch_orange(),
      stroke = FALSE,
      fillOpacity = 0.8,
      label = ~ as.character(short_title)
    )
}
```
  
```{r example-draw_map_selected_projects, eval=TRUE, out.width='100%'}
data("toy_projects_data_sf")

draw_map_selected_projects(
  projects_data_sf = toy_projects_data_sf
)
```
  
```{r tests-draw_map_selected_projects}
test_that("draw_map_selected_projects() returns a leaflet object", {
  expect_s3_class(
    draw_map_selected_projects(
      projects_data_sf = dummy_project_data_sf()
    ),
    c("leaflet", "htmlwidget")
  )
})
```
  
# Draw the map focused on one project

To create the map with a project as a point and the cantons of influence, you can use the `draw_map_focus_one_project()` function as follows *(here with a toy dataset)*:

```{r function-draw_map_focus_one_project}
#' Draw map of selected projects
#' 
#' @param projects_data_sf A sf data.frame containing coordinates of project 
#' main organisation and project `short_title`.
#' @param project_short_title Character. Id of the project.
#' @param cantons_sf Sf data. Cantons geometry. Mainly used for examples and unit testing purpose.
#' @param zoom_level An integer. The zoom level for the map. Defines
#' default zoom level.
#' 
#' @importFrom leaflet addCircleMarkers addPolygons
#' @importFrom dplyr filter select mutate rename
#' @importFrom tibble as_tibble
#' @importFrom tidyr separate_rows
#' @importFrom sf st_drop_geometry
#' 
#' @return A leaflet object.
#' 
#' @export
draw_map_focus_one_project <- function(
    projects_data_sf,
    project_short_title,
    cantons_sf = NULL,
    zoom_level = 8
){

  if (is.null(cantons_sf)) {
    cantons_sf <- read_cantons_sf()
  }
  
  # Create a coord_sf_project object
  projects_data_sf_filtered <- projects_data_sf |> 
    filter(short_title == project_short_title) 
  
  coord_sf_project <- projects_data_sf_filtered |> 
    select(short_title, geometry)
  
  # Extract target cantons from project_data_sf
  project_data_cantons_sf <- projects_data_sf_filtered |> 
    st_drop_geometry() |> 
    select(short_title, geo_range_id) |> 
    separate_rows(
      geo_range_id, 
      sep = ", "
    )
  
  # Create a cantons_sf_project object with column target_cantons (TRUE/FALSE)
  cantons_sf_project <- left_join(
    x = cantons_sf |> 
      select(HASC_1, NAME_1, geometry),
    y = project_data_cantons_sf |> 
      rename(HASC_1 = geo_range_id), 
    by = "HASC_1"
  ) |> 
    mutate(
      target_cantons = ifelse(
        is.na(short_title),
        FALSE, 
        TRUE
      )
    ) |> 
    select(- short_title)
  
  # Draw the map
  # Display target cantons in psch orange / others psch blue
  # Display selected project in psch orange
  # Nice to have
  # Display lines radiating from project to centroid of target cantons
  draw_map_base(zoom_level) |> 
    addPolygons(
      data = cantons_sf_project |> 
        filter(target_cantons == FALSE),
      weight = 1,
      color = psch_blue(),
      fillColor = psch_blue(),
      fillOpacity = 0.1
    ) |>
    addPolygons(
      data = cantons_sf_project |> 
        filter(target_cantons == TRUE),
      weight = 1,
      color = psch_orange(),
      fillColor = psch_orange(),
      fillOpacity = 0.5,
      label = ~ as.character(NAME_1)
    ) |>
    addCircleMarkers(
      data = coord_sf_project,
      color = psch_orange(),
      stroke = FALSE,
      fillOpacity = 0.8,
      label = ~ as.character(short_title)
    )
  
}
```
  
```{r example-draw_map_focus_one_project, eval=TRUE, out.width='100%'}
data("toy_projects_data_sf")
data("toy_cantons_sf")

draw_map_focus_one_project(
  projects_data_sf = toy_projects_data_sf,
  project_short_title = "1+1=3  PGV03.038", 
  cantons_sf = toy_cantons_sf
)
```
  
```{r tests-draw_map_focus_one_project}
test_that("Test that the map for one project is ok", {
  
  data("toy_projects_data_sf")
  data("toy_cantons_sf")

  expect_s3_class(
    draw_map_focus_one_project(
      projects_data_sf = toy_projects_data_sf,
      project_short_title = "1+1=3  PGV03.038", 
      cantons_sf = toy_cantons_sf
    ),
    c("leaflet", "htmlwidget")
  )
  
})
```
  
```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_map.Rmd", 
  vignette_name = "Draw the Switzerland maps with projects",
  check = FALSE,
  overwrite = TRUE
)
```
