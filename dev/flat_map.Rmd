---
title: "Draw the maps"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  eval=FALSE,
  echo=TRUE
)
```

```{r development, include=FALSE}
library(testthat)
library(sf)
library(leaflet)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

*The aim of this article is to show you how to reproduce the maps printed on the app.*

# Draw the map of filtered projects

To create the map with projects as points, you can use the `draw_map_selected_projects()` function as follows *(here with a toy dataset)*:

```{r function-draw_map_selected_projects}
#' Draw map of selected projects
#' 
#' @param projects_data_sf A sf data.frame containing coordinates of project 
#' main organisation and project `short_title`.
#' 
#' @param zoom_level An integer. The zoom level for the map. Defines
#' default zoom level.
#' 
#' @param language A character string. App language "fr", "de"...
#' 
#' @return A leaflet object.
#' 
#' @importFrom leaflet addCircleMarkers addPolygons markerClusterOptions
#' @importFrom leaflet addLabelOnlyMarkers labelOptions
#' 
#' @export
draw_map_selected_projects <- function(
    projects_data_sf,
    zoom_level = 8,
    language
){
  
  base_map <- draw_map_base(zoom_level)
  
  empty_data <- nrow(projects_data_sf) == 0
  if (
    empty_data
  ) {
    ch_centroid <- get_switzerland_centroid()
    final_map <- base_map |> 
    addLabelOnlyMarkers(
      lng = ch_centroid[["lng"]],
      lat = ch_centroid[["lat"]],
      label = translate_entry_server_side(
        language = language,
        key = "no_target_projects"
      ),
      labelOptions = labelOptions(
        noHide = TRUE,
        textsize = "20px",
        direction = "center"
      )
    )
  } else {
    final_map <- base_map |> 
      addPolygons(
        data = read_cantons_sf(),
        weight = 1,
        color = psch_blue(),
        fillColor = psch_blue(),
        fillOpacity = 0.2
      ) |>
      addCircleMarkers(
        data = projects_data_sf,
        color = psch_orange(),
        stroke = FALSE,
        fillOpacity = 0.8,
        layerId = ~ short_title,
        label = ~ as.character(short_title),
        clusterOptions = markerClusterOptions(
          showCoverageOnHover = FALSE,
          zoomToBoundsOnClick = FALSE,
          spiderLegPolylineOptions = list(
            weight = 1.5, 
            color = psch_orange(), 
            opacity = 0.5
          ),
          freezeAtZoom = zoom_level, 
          spiderfyDistanceMultiplier = 1.5
        )
      )
  }
  
  class(final_map) <- c(
    class(final_map),
    "all-projects"
  )
  
  return(final_map)
  
}
```
  
```{r example-draw_map_selected_projects, eval=TRUE, out.width='100%'}
data("toy_projects_data_sf")

draw_map_selected_projects(
  projects_data_sf = toy_projects_data_sf
)
```
  
```{r tests-draw_map_selected_projects}
test_that("draw_map_selected_projects() returns a leaflet object", {
  expect_s3_class(
    draw_map_selected_projects(
      projects_data_sf = dummy_project_data_sf()
    ),
    c("leaflet", "htmlwidget")
  )
})
```
  
# Draw the map focused on one project

To create the map with a project as a point and the cantons of influence, you can use the `draw_map_focus_one_project()` function as follows *(here with a toy dataset)*:

```{r function-draw_map_focus_one_project}
#' Draw the map focused on one project
#' 
#' @param projects_data_sf A sf data.frame containing coordinates of project 
#' main organisation and project `short_title`.
#' @param id_project Character. Id of the project.
#' @param cantons_sf Sf data. Cantons geometry. Mainly used for examples and unit testing purpose.
#' @param zoom_level An integer. The zoom level for the map. Defines
#' default zoom level.
#' 
#' @importFrom leaflet addCircleMarkers addPolygons addPolylines labelOptions
#' @importFrom dplyr filter
#'  
#' @return A leaflet object.
#' 
#' @export
draw_map_focus_one_project <- function(
    projects_data_sf,
    id_project,
    cantons_sf = NULL,
    zoom_level = 8
){

  if (is.null(cantons_sf)) {
    cantons_sf <- read_cantons_sf()
  }
  
  # Extract the elements needed for the map
  ## The coordinates of the project
  ## The polygons of the canton with the info influenced/not influenced
  ## If appropriate, the lines between the projects and the cantons influenced
  geo_elements_influence <- get_influence_project(
    projects_data_sf = projects_data_sf,
    id_project = id_project,
    cantons_sf = cantons_sf
  )
  
  # Draw the map
  ## Add the cantons not influenced
  map_with_cantons_not_influenced <- draw_map_base(zoom_level) |> 
    addPolygons(
      data = geo_elements_influence$cantons_sf_project |> 
        filter(
          target_cantons == FALSE
          ),
      weight = 1,
      color = psch_blue(),
      fillColor = psch_blue(),
      fillOpacity = 0.2
    ) 
   
  ## Add the cantons influenced if appropriate and the lines between the project and them
  if (!is.null(geo_elements_influence$cantons_influenced_lines)) {
    
    # Print the cantons in orange
    map_with_cantons_influenced <- map_with_cantons_not_influenced |> 
      addPolygons(
      data = geo_elements_influence$cantons_sf_project |> 
        filter(
          target_cantons == TRUE
        ),
      weight = 2,
      color = psch_dark_orange(),
      fillColor = psch_orange(),
      fillOpacity = 0.5,
      label = ~ gsub("^CH\\.", "", as.character(HASC_1)), 
      labelOptions = labelOptions(
        style = list("font-size" = "12px")  # Adjust the font size here
        )
      ) 
    
    # Print the lines in orange
    map_geo_influence <- map_with_cantons_influenced |> 
      addPolylines(
       data = geo_elements_influence$cantons_influenced_lines, 
       color = psch_dark_orange(), 
       weight = 2
      )
      
  } else {
    
    map_geo_influence <- map_with_cantons_not_influenced
    
  }
    
  map_project_and_geo_influence <- map_geo_influence |>
    addCircleMarkers(
      data = geo_elements_influence$coord_sf_project,
      color = psch_orange(),
      stroke = FALSE,
      fillOpacity = 0.8,
      label = ~ as.character(short_title)
    )
  
  class(map_project_and_geo_influence) <- c(
    class(map_project_and_geo_influence),
    "one-project"
  )
  
  return(map_project_and_geo_influence)
  
}
```
  
```{r example-draw_map_focus_one_project, eval=TRUE, out.width='100%'}
data("toy_projects_data_sf")
data("toy_cantons_sf")

draw_map_focus_one_project(
  projects_data_sf = toy_projects_data_sf,
  id_project = "1+1=3  PGV03.038", 
  cantons_sf = toy_cantons_sf
)
```
  
```{r tests-draw_map_focus_one_project}
test_that("Test that the map for one project is ok", {
  
  data("toy_projects_data_sf")
  data("toy_cantons_sf")

  expect_s3_class(
    draw_map_focus_one_project(
      projects_data_sf = toy_projects_data_sf,
      id_project = "1+1=3  PGV03.038", 
      cantons_sf = toy_cantons_sf
    ),
    c("leaflet", "htmlwidget")
  )
  
})
```
  
```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_map.Rmd", 
  vignette_name = "Draw the Switzerland maps with projects",
  check = FALSE,
  overwrite = TRUE,
  open_vignette = FALSE
)
```
